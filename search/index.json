[{"content":"引言 Git 是一个用于管理项目源码的软件，可以用于：\n新建分支开发新功能（branch） 回滚代码到指定版本（commit） 同步本地代码和远程仓库（remote） 安装 下载安装 here 命令行安装 使用 下面按 Git 功能来解释 Git 概念，以及一些简单的 Git 命令。\n现在有个新项目，需要依次实现 a、b、c三个功能。\n新功能开发 新功能很容易实现，新建项目 P，在项目 P 上开发功能 a\n1 2 3 mkdir Project // 项目名 cd Project git init // 初始化，此时会有默认分支 master 可以把项目理解为最初的起源（origin），每个分支（branch）代表项目的一种可能性，分分支与分支间彼此隔离互不干扰。\n变更项目需求，优先开发功能 b 此时功能 a 开发到一半，需要将功能 b 优先级提前，功能 a 暂时搁置，但要删掉后重新开始吗？但功能 a 后面还是要完成的。因此，考虑将功能 a 暂存，重新开始开发功能 b。\n1 2 git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Pause a\u0026#34; // 暂存功能 a git checkout branch -b b // 新建分支 b（需要删除功能 a 相关代码，只保留项目基本框架） git add . ：此项目（准确来说是当前文件夹）的所有变更都添加进来\ngit commit -m \u0026quot;Pause a\u0026quot;：为此次变更生成一个版本并添加信息记录变更内容\n此时回顾上一小节，如果当初 master 分支只有基本的项目框架，开发功能 a 时新建分支 feature/a 是否更合理？\n项目要赶进度，协调新同事来完成功能 a 两个人该怎么协同合作一块完成项目呢？将代码拷贝一份给同事吗？但这样两个人如果修改了同一份文件，到时怎么合并？怎么确认同事只在分支 a 上完成？能否提供一个公共目录，自己和同事的项目都可以随时与其同步？\n这就是远程仓库（remote）：远程仓库是一个部署在服务器上的代码仓库，供多人协作完成项目，可以随时推送（push）和拉取（pull）源码。\n推送项目到远程仓库：\n1 2 3 4 5 6 7 git remote add origin https://github.com/xxx/P // 关联远程仓库地址 git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Finish xxx func\u0026#34; // 保存分支 b 的项目进度 git checkout master // 切换到分支 master git push origin --set-upstream master // 关联本地分支 master 和远程仓库的 master （分支需要一一对应，分支名称最好保持一致，避免引起歧义） git checkout b // 继续开发功能 b origin 是地址 https://github.com/xxx/P 的简称，这表示一个项目可以有多个远程仓库地址（免费版 \u0026amp;\u0026amp; 收费版）\ngit checkout [分支名]：根据分支名进行分支切换\ngit push origin --set-upstream [分支名]：将本地分支推送到 origin/[分支名] 并进行关联\n同事拉取项目并继续开发功能 a\n1 2 git clone https://github.com/xxx/P // 使用 clone 命令将项目从远程仓库复制到本地 git checkout -b a // 在 master 分支上新建分支 a 继续开发功能 a（新建分支 a 与分支 b 对应，互不影响） clone 到本地的项目默认分支一般为 master（可以在远程仓库中设置）\n功能 a 和 b 开发的差不多了，要开始合并为一个分支并上线。该怎么操作呢？先将分支 a 合并到 master，然后再将分支 b 合并过去，如果两个分支更改了同一份文件，就需要解决文件更改冲突的问题了。 1 2 3 git checkout master // 切换到分支 master git merge origin/a // 合并分支 a 并解决冲突（假设分支 a 和 分支 b 都已经推送到远程仓库了） git merge origin/b // 合并 分支 b 并解决冲突 合并期间 master 分支不稳定（不确定会不会有分支冲突）\n此时 master 分支可以去提测了，在提测的时候需要继续开发功能 c，该怎么做？ 继续在 master 分支上进行修改吗？虽然可以，但不建议这么做：\n测试出现问题时需要修复 万一又有新功能 d 需要实现呢 所以应该在 master 上新建分支 c 进行开发。同时在提测后应该暂时冻结分支 master，避免测试发现问题后找不到对应的版本。那么有什么好办法用于冻结分支 master 呢？不妨使用 git tag 命令。\n1 git tag v0.0.1-rc.01 // 首个版本提测 其实上述方法中有些操作可以改进：\n一开始就在 master 上新建分支 a 进行开发 为保持 master 分支的稳定，引入新分支 develop 充当 master 分支的不稳定版本（预览版本） 规范分支名称 master：主分支。维护项目稳定代码，每个tag都表示一个稳定的服务版本。\ndevelop：开发分支。用于 checkout [功能|修复]分支和 merge [功能|修复]分支。develop 分支测试无误后就可以合并到 master 分支并上线。\nfeature：功能分支。用于开发新功能。\nfix：修复分支。用于修复 develop 分支在测试时遇到的问题。\n重新梳理后，可以按如下方式进行：\n上述流程是一个比较流行的 Git 分支和项目开发流程，但也需要考虑如下情况：\n在 develop 分支测试时，此时 feature 分支能否合并进来？如果合并进来后该怎么处理可能存在的 fix 分支？ 方案一：feature 分支要在 develop 分支测试完成后再合并\n方案二：feature 分支合并进 develop 分支后重新提测\n方案三：放松片刻，不用着急开发新功能\n如果线上服务出现问题需要修复，该怎么做？ 在 master 分支上 checkout 一个 fix 分支修复线上问题，测试无误后合并到 master 分支，然后将 mater 分支合并到 develop 分支。\n总结 其他常用命令：\n1 2 3 4 5 git status // 查看当前 git 状态 git diff aaa bbb // 对比 aaa 和 bbb 的区别 git fetch // 更新远程仓库 git restore xxx // 还原 xxx 文件 git rebase -i xxx // 回滚代码到指定版本 名词解释：\n工作区：修改后没有执行 git add xxx 命令，可还原（git restore xxx） 暂存区：git add xxx 后文件从工作区转移到暂存区，可撤销（git restore \u0026ndash;staged xxx） 本地仓库：git commit -m \u0026quot;xxx\u0026quot; 后文件从暂存区转移到本地仓库，可回滚（git reset xxx 或 git rebase xxx） 以上只是 Git 工具和命令的基础部分，还有很多其他优秀的功能和命令，因本人精力有限，无法在此详细编写，特此推荐以下优秀书籍和项目：\nPro Git\nGit 源码\nOh My Git!\nlearnGitBranching\n","date":"2023-05-02T23:04:59+08:00","permalink":"https://haxung.github.io/p/git-%E7%AE%80%E4%BB%8B/","title":"Git 简介"},{"content":"引言 hugo 是一个用 Go 语言实现的静态网站生成器。把符合规则的 markdown 文档转为静态网站的 html、css 等文件的工具， 即将 markdown 文档转为博客。\n提供三个版本可供安装，版本区别如下所示，推荐安装 extend 版本。\n版本 说明 standard 基础版本，适用于一般的静态网站生成 extend 包含 standard 的所有功能，额外支持 SCSS/SASS 编译和 resources 处理功能 extended/deploy 包含 extend 的所有功能，额外包含 hugo 内置的 hugo deploy 功能，可以将网站部署到云存储服务（AWS S3、Google Cloud Storage 等） 也可以直接从 GitHub 中下载压缩包后解压\n注意：需要将解压后的路径地址添加到系统环境变量（PATH）！！！\n创建站点 需要提前安装 hugo 和 Git\n初始化：在本地创建 quickstart 文件夹，并在文件夹中生成 hugo 模板和默认配置。\n1 2 hugo new site quickstart cd quickstart 修改内容：quickstart 设置为项目根目录并 git 初始化，通过 git submodule 方式将 gohugo-theme-ananke 主题下载到 quickstart/themes/ananke 路径下，修改 hugo.toml 文件设置主题为 ananke。\n1 2 3 git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 主题名需要与 themes 文件夹下的目录名称保持一致\n主题 ananke 文件夹结构与 quickstart 结构基本相同，可以理解为 quickstart 中为默认配置， 选择 ananke 主题后，ananke 中的配置替换掉默认配置，因此可以轻松替换网站主题\n本地部署：运行如下命令后可以打开浏览器输入 localhost:1313 查看网站效果。\n1 hugo server hugo server 运行后会生成 public 和 resources 目录，其中 public 才是网站的本体。\n可以在 here 选择不同的 hugo 主题。\n当然也可以自己设置主题，并将其发布。\n自动化部署 写博客不仅仅是为方便自己，有时候也希望帮助他人。那么怎么样才能将博客分享到互联网上？ 这里提供一个简单方便的做法：github pages（gh-pages）。\ngh-pages gh-pages 是 GitHub 推出的一项服务。它支持将 Git 仓库中的静态页面转为一个网站，完美契合我们的需求。\n需要注册一个 GitHub 账号\n创建仓库，仓库名为 {user}.github.io（user 为创建账号时填写的用户名，创建时要求此名称唯一）。 git clone {user}.github.io 到本地。 将 quickstart 项目生成的 public 文件夹复制到 {user}.github.io 项目中。 在 {user}.github.io 中添加项目变更并推送到远程仓库。 回顾上述流程，不难发现操作过于复杂，且博客经常更新，有没有简单点的方式呢？ 答案是可以，GitHub Actions 就能解决此问题。\nGitHub Actions GitHub Actions 是 GitHub 提供的 DevOps 功能，可以按需执行自动化流程。\n上述操作简化如下：\n在 quickstart 中变更博客内容 提交 quickstart 项目，自动运行 hugo server 命令并生成 public 目录 将 public 目录复制到 {user}.github.io 项目中 简化后我们只需要专心致志写博客即可（quickstart）。\n要将 quickstart 中的 public 写入到 {user}.github.io 中，就要求获取 {user}.github.io 仓库的写权限。 因此需要配置 {user}.github.io 的 Deploy key。 即在 {user}.github.io 的 Deploy keys 中配置公钥，在 quickstart 的 Secrets and variables/Actions 中配置私钥（变量名为 DEPLOY_PRIVATE_KEY）。\nGitHub Actions 的 CI/CD 流程通过 YAML 文件配置，需要放在项目的 .github/workflows 目录中，下面是我配置的 deploy.yml 文件，仅供参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 name: Deploy to public repo # 流水线（流程）名称 on: # 触发条件：仅在 master 分支上的 push 和 pull_request 操作才会运行 push: branches: [ master ] pull_request: branches: [ master ] jobs: # 配置多个任务（这里只有 build 任务，即希望提交时自动运行 hugo server） build: runs-on: ubuntu-latest # build 任务运行的基础环境，这里需要注意：以下所有步骤都是在 ubuntu-latest 的容器（虚拟机）中运行，不会影响项目仓库，且在执行完毕后销毁此容器（回收资源） steps: # 将任务拆分成多个步骤 - name: Checkout repo # 将项目 clone 到 ubuntu-latest uses: actions/checkout@v4 - name: Cache Hugo resources # 缓存项目需要的依赖项，加快流程（其实此博客项目没什么好缓存的。。。） uses: actions/cache@v4 env: cache-name: cache-hugo-resources with: path: resources key: ${{ env.cache-name }} - uses: actions/setup-go@v5 # 安装指定版本的 Go（hugo 运行需要 Go 环境） with: go-version: 1.22.12 - run: go version - name: Cache Go Modules # 拉取项目需要的依赖库（go.mod 中记录的依赖库信息） uses: actions/cache@v4 with: path: | ~/.cache/go-build ~/go/pkg/mod key: ${{ runner.os }}-go-${{ hashFiles(\u0026#39;**/go.sum\u0026#39;) }} restore-keys: | ${{ runner.os }}-go- - name: Setup Hugo # 安装指定版本的 hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: 0.145.0 extended: true - name: Build # 在容器中运行 hugo --minify --gc 命令生成 public 文件夹 run: | hugo --minify --gc cp CNAME public cp README.md public - name: Deploy to public repo # 将生成的 public 目录推送到指定的仓库和分支中 uses: s0/git-publish-subdir-action@develop env: REPO: git@github.com:haxung/haxung.github.io.git BRANCH: master FOLDER: public SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_PRIVATE_KEY }} # 这里就是配置的 REPO 项目的私钥，通过变量名取值（切记不要明文配置，不然密钥泄露后谁都可以往 REPO 中推送一些奇奇怪怪的内容。。。） ","date":"2023-05-02T16:05:32+08:00","permalink":"https://haxung.github.io/p/hugo-%E7%AE%80%E4%BB%8B/","title":"hugo 简介"},{"content":"基础操作 在介绍 MySQL 基础操作前，需要先安装 MySQL 。\nLinux 系统安装 MySQL\n1 2 3 4 5 6 7 8 # debian, ubuntu sudo apt update \u0026amp;\u0026amp; sudo apt install mysql # centos 7 yum update \u0026amp;\u0026amp; install mysql # centos 8, rocky linux dnf update \u0026amp;\u0026amp; dnf install mysql Windows 安装 MySQL 官网下载 msi 软件，一步步安装（可以参考菜鸟教程）。\nDocker 安装 MySQL 官方镜像\n1 2 3 4 5 docker serach mysql docker pull mysql:latest docker run --name mysql-study -e MYSQL_ROOT_PASSWORD=\u0026#34;\u0026lt;ENTER YOUR PASSWORD\u0026gt;\u0026#34; -d mysql:latest docker container ls docker logs mysql-study 数据库操作 下面将创建数据库 mysql_test，在此数据库下创建数据表 test，然后进行一系列的数据库操作。\n连接 MySQL Server\n1 2 3 4 5 # 使用容器时需要先进入容器内 docker exec -it mysql-study /bin/bash `MySQL` -u root -p \u0026lt;ENTER YOUR PASSWORD\u0026gt; 进入 MySQL Server 后每条指令都需要以 ; 作为指令结束的标志。\n查看帮助\n1 HELP; 查看数据库\n1 SHOW databases; 创建数据库\n1 2 3 4 CREATE DATABASE test01; # 设置数据库编码和排序方式，可以在库级别设置，也可以在表级别设置 CREATE DATABASE test01 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; SHOW databases; 查看库编码格式\n1 2 3 4 5 6 7 # 查看单个数据库 SELECT default_character_set_name, default_collation_name FROM information_schema.schemata WHERE schema_name = \u0026#39;test01\u0026#39;; # 查看所有数据库 SELECT schema_name, default_character_set_name, default_collation_name FROM information_schema.schemata; 设置或更新库编码格式\n1 ALTER DATABASE test01 CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; 重命名数据库\nMySQL 5.1 版本之前可以使用\n1 RENAME DATABASE test01 TO mysql_test; 建新库，重命名表名，删除老库\n1 2 3 4 CREATE DATABASE mysql_test CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; # test01 中所有的表名都要更改，相当于将表从 test01 移动到 mysql_test RENAME TABLE test01.tb TO mysql_test.tb; DROP DATABASE test01; 建新表，导出老表，导入新表，删除老表\n1 CREATE DATABASE mysql_test CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; 1 2 mysqldump -u root -p\u0026lt;ENTER YOUR PASSWORD\u0026gt; --set-gtid-purged=OFF test01 \u0026gt; /tmp/test01.sql mysqldump -u root -p\u0026lt;ENTER YOUR PASSWORD\u0026gt; mysql_test \u0026lt; /tmp/test01.sql 1 DROP DATABASE test01; 尽量不要变更数据库名称！！！\n数据表操作 创建数据表\n1 2 3 4 5 6 7 8 9 10 CREATE TABLE mysql_test.test ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, gender BOOLEAN, address TEXT, birth DATE COMMENT \u0026#39;format just like 1970-01-01\u0026#39;, description VARCHAR(255), create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ) ENGINE = InnoDB CHARSET = utf8mb4; 表级别编码方式高于库级别编码方式。\nMySQL 有多种存储引擎，各有优缺点。其中，最常用的两种存储引擎是 InnoDB 和 MyISAM。\nInnoDB 是 MySQL 5.5 及以后版本中的默认存储引擎。它支持事务、使用行级锁、支持外键关联、支持热备份等特性，容灾性强，能够在崩溃后安全恢复。 MyISAM 则不支持事务、使用表级锁、并发性差、主机宕机后易损坏、灾难恢复性不佳。但是，它可以配合锁实现操作系统下的复制备份、迁移，数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能。 总之，InnoDB 更适合写密集的表，而 MyISAM 更适合读密集的表。\n查看建表语句\n1 SHOW CREATE TABLE mysql_test.test; 查看数据表结构\n1 2 3 DESCRIBE mysql_test.test; SHOW COLUMNS FROM mysql_test.test; 设置或更新存储引擎\n1 2 ALTER TABLE mysql_test.test ENGINE = MyISAM; ALTER TABLE mysql_test.test ENGINE = InnoDB; 设置或更新编码\n1 ALTER TABLE mysql_test.test CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 重命名表名\n1 2 RENAME TABLE mysql_test.test TO mysql_test.test01; RENAME TABLE mysql_test.test01 TO mysql_test.test; 添加列\n1 ALTER TABLE mysql_test.test ADD COLUMN description TEXT; TEXT 类型 IO 性能较差，适合存储大文本数据。\n更改列\n1 ALTER TABLE mysql_test.test CHANGE COLUMN address address VARCHAR(255) NOT NULL COMMENT \u0026#39;address in id card\u0026#39;; 删除列\n1 ALTER TABLE mysql_test.test DROP COLUMN description; 删除数据表\n1 DROP TABLE mysql_test.test; 字段操作 添加主键\n1 2 3 ALTER TABLE mysql_test.test ADD CONSTRAINT ID PRIMARY KEY (id); # 也可以变更列属性 ALTER TABLE mysql_test.test CHANGE COLUMN id id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY; CONSTRAINT ID 的意思是为主键取个名称 ID。\n删除主键\n1 2 3 # 对于自增主键，必须先去掉自增属性，才能删除主键属性 ALTER TABLE mysql_test.test MODIFY id BIGINT UNSIGNED NOT NULL; # 尽量只删除自增属性 ALTER TABLE mysql_test.test DROP PRIMARY KEY; 一张表只能有一个主键，主键自带唯一性且不能为空 主键应当不影响业务逻辑，也不应该更新主键值\n添加索引\n1 2 3 4 # 添加索引 ALTER TABLE mysql_test.test ADD INDEX name (name); # 添加唯一索引 ALTER TABLE mysql_test.test ADD UNIQUE INDEX (name); 删除索引\n1 ALTER TABLE mysql_test.test DROP INDEX name; 添加索引能够加快检索速度，唯一索引确保数据唯一性，索引可以为空 考虑到会建立多个索引，可以为每个索引添加名称（名称不可以重复），不添加时默认使用列名\n添加联合索引\n1 2 3 4 # 添加联合索引 ALTER TABLE mysql_test.test ADD INDEX name_address (name, address); # 添加唯一联合索引 ALTER TABLE mysql_test.test ADD UNIQUE INDEX name_address (name, address); 删除联合索引\n1 ALTER TABLE mysql_test.test DROP INDEX name_address; 联合索引名称需要与列名称相关，最好能够望名知义 联合索引的排序和查询都是按照字段的先后顺序进行的，所以让数据重复概率低，字符短，经常使用的列排在联合索引的最左边 联合索引遵循最左前缀匹配原则，即查询条件中只能使用索引的最左侧部分 增删改查操作 增加数据\n1 INSERT INTO mysql_test.test (name, address) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;JX\u0026#39;); 只能使用单引号，不能使用双引号\n查询数据\n1 2 3 4 5 6 7 8 9 10 # 查询表中所有数据 SELECT * FROM mysql_test.test; # 查询表中单列所有数据 SELECT name FROM mysql_test.test; # 条件查询 SELECT name, address FROM mysql_test.test WHERE id = 1; # 多条件查询 SELECT name, address FROM mysql_test.test WHERE id = 1 AND gender = false; # 按 id 升序排序，从 id\u0026gt;0 的数据中查询前 10 条数据，不足 10 条时返回所有数据 SELECT name, gender, address FROM mysql_test.test WHERE id \u0026gt; 0 ORDER BY id LIMIT 10; 更新数据\n1 2 3 4 # 更新表中所有数据 UPDATE mysql_test.test SET gender = true; # 更新表中满足条件的数据 UPDATE mysql_test.test SET gender = true WHERE id = 1; 删除数据\n1 2 3 4 # 清空表中所有数据 DELETE FROM mysql_test.test; # 清空表中满足条件的数据 DELETE FROM mysql_test.test WHERE gender = true; ","date":"2023-04-05T21:47:40+08:00","permalink":"https://haxung.github.io/p/mysql-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","title":"MySQL 基础操作"},{"content":"外键介绍 以学生为例，使用数据库 student：\n1 2 CREATE DATABASE IF NOT EXISTS `student` CHARACTER SET utf8mb4; USE `student`; 现在 student 数据库中已经有了一张表 info ，用于统计学生信息，表结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 DROP TABLE IF EXISTS `info`; CREATE TABLE `info` ( id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, number INTEGER UNSIGNED NOT NULL UNIQUE COMMENT \u0026#39;student id\u0026#39;, name VARCHAR(255) NOT NULL, gender BOOLEAN NOT NULL COMMENT \u0026#39;true MAN \u0026amp;\u0026amp; false WOMAN\u0026#39;, birth DATE NOT NULL, description VARCHAR(255), create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ) ENGINE = InnoDB CHARSET = utf8mb4; 此时，需要登记当前学期（第一学期）每位同学的语数英成绩，可以创建下表 first_term_score：\n1 2 3 4 5 6 7 8 9 10 11 12 DROP TABLE IF EXISTS `first_term_score`; CREATE TABLE `first_term_score` ( id INTEGER UNSIGNED AUTO_INCREMENT PRIMARY KEY, number INTEGER UNSIGNED NOT NULL UNIQUE COMMENT \u0026#39;student id\u0026#39;, chinese INTEGER UNSIGNED NOT NULL, math INTEGER UNSIGNED NOT NULL, english INTEGER UNSIGNED NOT NULL, create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ) ENGINE = InnoDB CHARSET = utf8mb4; 看上去表 first_term_score 没多大问题，但是这张表与上表 info 息息相关：first_term_score 表中的 number 字段依赖于 info 表中的 number 字段：即学号（学生）可以没有成绩，但成绩不能没有学号。\n实际上，在数据库中这个概念称为 外键(foreign key)，即 表 info 中 number 字段是表 first_term_score 的外键。info 称为主表，first_term_score 称为外表；表 info 中的 number 列称为参照列，表 first_term_score 中的 number 列称为外键列。外键有以下特性：\n参照列在主表中具有唯一性 (PRIMARY KEY 或者 UNIQUE) 虽然主表中的参照列和从表中的外键列都可以为空，但强烈建议主表中参照列设置为 NO NULL 主表参照列和从表外键列必须具有相同的数据类型，长度和精度 在删除主表中一条数据时，必须确保这条数据的外键值没有在从表中被使用（此为默认设置：ON DELETE NO ACTION 或者 ON DELETE RESTRICT） 当使用 ON DELETE CASCADE 时，删除主表中的一条数据会自动删除从表中关联该数据外键值的数据（请谨慎使用） 当使用 ON DELETE SET NULL 时，删除主表中的一条数据会设置从表中外键相关联的外键值为 NULL（请谨慎使用） 当使用 ON UPDATE CASCADE 时，更新主表的外键值会自动更新从表中使用此外键的外键值 外键列在从表中可以重复（即主表外键关联多条从表数据） 主从表可以建立双向外键关系，以此来确保数据在不同表之间的一致性和完整性 主表的参照列可以关联多张从表的外键列 表既可以有参照列，也可以有外键列 主表可以有多个参照列，从表可以有多个外键列 可以设置外键的外键，即从表中的外键列可以设置为另一张表（从表的从表）的外键。这被称为嵌套（nested）外键关系，或者也可以称之为级联（cascading）外键关系 外键列既可以是单列，也可以是多列联合，即联合唯一索引 如果表太多，外键关系太复杂，或许可以思考下换种方式来实现 外键使用 可以使用下面的命令为从表 first_term_score 添加外键约束：\n设置主表参照列为主键\n1 ALTER TABLE `info` ADD PRIMARY KEY number (number); 或者设置为唯一索引\n1 ALTER TABLE `info` ADD UNIQUE number (number); 或者变更字段属性（添加非空约束）\n1 2 3 ALTER TABLE `info` CHANGE COLUMN number number INTEGER UNSIGNED NOT NULL UNIQUE; 为从表外键列建立索引\n1 ALTER TABLE `first_term_score` ADD INDEX number (number); 或者建立唯一索引\n1 ALTER TABLE `first_term_score` ADD INDEX number (number); 设置从表外键约束\n1 2 3 4 ALTER TABLE `first_term_score` ADD CONSTRAINT number FOREIGN KEY (number) REFERENCES `info` (number) ON DELETE CASCADE ON UPDATE CASCADE; ","date":"2023-03-27T22:51:18+08:00","permalink":"https://haxung.github.io/p/mysql-%E5%A4%96%E9%94%AE%E4%BB%8B%E7%BB%8D/","title":"MySQL 外键介绍"}]